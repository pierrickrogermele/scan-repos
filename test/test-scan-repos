#!/bin/bash

#############
# CONSTANTS #
#############

SCRIPTDIR=$(cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd)
SCANREPOS=$SCRIPTDIR/../scan-repos

#########
# CHECK #
#########

function check {

	local testfct=$1
	shift

	# Run test
	echo -n $testfct "$@" ...
	test_output=$($testfct "$@" 2>&1)

	# Failure
	if [ $? -gt 0 ] ; then
		echo failure.
		echo $test_output
		exit 1
	fi

	# Success
	echo success. 
}

##############
# CHECK SAME #
##############

# Checks that two files have the same containt
function check_same {

	local file1=$1
	local file2=$2

	if ! diff $file1 $file2 >/dev/null ; then
		echo "Files $file1 and $file2 are different."
		return 1
	fi

	return 0
}

##################
# RUN SCAN-REPOS #
##################

function run_scanrepos {

	local output_filename=$1
	shift

	$SCANREPOS "$@" >$output_filename.output 2>&1
}

###########
# RUN GIT #
###########

function run_git {
	git "$@" >/dev/null 2>&1
}

###############
# CLEAN REPOS #
###############

function clean_repos {
	rm -rf repos-*
}


###################
# MAKE BARE REPOS #
###################

function mk_bare_repos {

	local repos=$1

	mkdir $repos
	cd $repos
	run_git init --bare
	cd ..
}

##############
# MAKE REPOS #
##############

function mk_repos {

	local repos="$1"
	local file="$2"

	mkdir "$repos"
	cd "$repos"
	touch "$file"
	run_git init
	run_git add .
	run_git commit -m "Init."
	cd ..
}

#####################
# MODIFY REPOS FILE #
#####################

function modify_repos_file {

	local repos=$1
	local file=$2

	cd $repos
	echo "AAA" >> $file
	run_git add .
	run_git commit -m "Add some text."
	cd ..
}

#####################
# DELETE REPOS FILE #
#####################

function delete_repos_file {

	local repos=$1
	local file=$2

	cd $repos
	rm $file
	run_git add .
	run_git commit -m "Removed file."
	cd ..
}

######################
# TEST MODIFIED FILE #
######################

function test_modified_file {
	clean_repos
	mk_repos repos-a a
	echo "AAA" >> repos-a/a
	run_scanrepos modified_file repos-a || return 1
	check_same modified_file.output modified_file.output.ref || return 1
}

#####################
# TEST DELETED FILE #
#####################

function test_deleted_file {
	clean_repos
	mk_repos repos-a a
	rm repos-a/a
	run_scanrepos deleted_file repos-a || return 1
	check_same deleted_file.output deleted_file.output.ref || return 1
}

#######################
# TEST UNTRACKED FILE #
#######################

function test_untracked_file {
	clean_repos
	mk_repos repos-a a
	touch repos-a/some_untracked_file.txt
	run_scanrepos untracked_file repos-a || return 1
	check_same untracked_file.output untracked_file.output.ref || return 1
}

#####################
# TEST BRANCH AHEAD #
#####################

function test_branch_ahead {
	clean_repos
	mk_repos repos-orig a
	run_git clone repos-orig repos-clone
	modify_repos_file repos-clone a
	run_scanrepos branch_ahead repos-clone || return 1
	check_same branch_ahead.output branch_ahead.output.ref || return 1
}

######################
# TEST BRANCH BEHIND #
######################

function test_branch_behind {
	clean_repos
	mk_repos repos-orig a
	run_git clone repos-orig repos-clone
	modify_repos_file repos-orig a
	cd repos-clone
	run_git fetch
	cd ..
	run_scanrepos branch_behind repos-clone || return 1
	check_same branch_behind.output branch_behind.output.ref || return 1
}

##############
# TEST FETCH #
##############

function test_fetch {

	local flags=$1

	clean_repos
	mk_repos repos-orig a
	run_git clone repos-orig repos-clone
	modify_repos_file repos-orig a
	run_scanrepos fetch $flags repos-clone || return 1
	check_same fetch.output branch_behind.output.ref || return 1
}

#############
# TEST PULL #
#############

function test_pull {

	local flags=$1

	clean_repos
	mk_repos repos-orig a
	run_git clone repos-orig repos-clone
	modify_repos_file repos-orig a
	run_scanrepos pull $flags repos-clone || return 1
	check_same pull.output pull.output.ref || return 1
}

#############
# TEST PUSH #
#############

function test_push {

	local flags=$1

	clean_repos
	mk_bare_repos repos-bare
	mk_repos repos-orig a
	cd repos-orig
	run_git remote add origin ../repos-bare
	run_git push -u origin master
	cd ..
	modify_repos_file repos-orig a
	run_scanrepos push $flags repos-orig || return 1
	check_same push.output push.output.ref || return 1
}

######################
# TEST PUSH CONFLICT #
######################

function test_push_conflict {

	local flags=$1

	# Create a bare repos and an orig repos
	clean_repos
	mk_bare_repos repos-bare
	mk_repos repos-orig a
	cd repos-orig
	run_git remote add origin ../repos-bare
	run_git push -u origin master
	cd ..

	# Clone orig repos
	run_git clone repos-orig repos-clone

	# Modify orig repos
	modify_repos_file repos-orig a
	run_scanrepos push_conflict_orig $flags repos-orig || return 1
	check_same push_conflict_orig.output push.output.ref || return 1

	# Modify clone repos and try to push
	delete_repos_file repos-clone a
	run_scanrepos push_conflict_clone $flags repos-clone || return 1
	check_same push_conflict_clone.output push_conflict_clone.output.ref || return 1
}

######################
# TEST PUSH CONFLICT #
######################

function test_unknown_option {

	local flags=$1

	! run_scanrepos unknown_option $flags || return 1
	check_same unknown_option.output unknown_option.output.ref || return 1
}

##################
# TEST REPOSPATH #
##################

function test_repospath {

	# Create a repository with a modified file
	clean_repos
	mk_repos repos-a a
	echo "AAA" >> repos-a/a

	# Outside repository
	run_scanrepos repospath_outside repos-a || return 1
	check_same repospath_outside.output repospath_outside.output.ref || return 1

	# Outside repository with environment variable set to repository folder
	REPOSPATH=repos-a run_scanrepos repospath_outside_envvarrepos  || return 1
	check_same repospath_outside_envvarrepos.output repospath_outside.output.ref || return 1

	# Outside repository with environment variable set to relative current directory
	REPOSPATH=. run_scanrepos repospath_outside_envvarrelcur  || return 1
	check_same repospath_outside_envvarrelcur.output repospath_outside_envvarrelcur.output.ref || return 1

	# Outside repository with environment variable unset
	REPOSPATH= run_scanrepos repospath_outside_envvarunset  || return 1
	check_same repospath_outside_envvarunset.output repospath_outside_envvarrelcur.output.ref || return 1

	# Inside repository
	cd repos-a
	run_scanrepos ../repospath_inside . || return 1
	cd ..
	check_same repospath_inside.output repospath_inside.output.ref || return 1

	# Inside repository with environment variable unset
	cd repos-a
	REPOSPATH= run_scanrepos ../repospath_inside_envvarunset  || return 1
	cd ..
	check_same repospath_inside_envvarunset.output repospath_inside.output.ref || return 1
}

#############################
# TEST MULTIPLE REPOS PATHS #
#############################

function test_multiple_repospaths {

	# Create two repositories with modified files
	clean_repos
	mk_repos repos-a a
	mk_repos repos-b b
	echo "AAA" >> repos-a/a
	echo "AAA" >> repos-b/b

	# Using command line
	run_scanrepos multiple_repospaths repos-a repos-b  || return 1
	check_same multiple_repospaths.output multiple_repospaths.output.ref || return 1

	# Using environment variable
	REPOSPATH=repos-a:repos-b run_scanrepos multiple_repospaths  || return 1
	check_same multiple_repospaths.output multiple_repospaths.output.ref || return 1

	# Using default current directory
	REPOSPATH= run_scanrepos multiple_repospaths_curdir  || return 1
	check_same multiple_repospaths_curdir.output multiple_repospaths_curdir.output.ref || return 1
}

##############
# TEST SPACE #
##############

function test_space {

	# Create arepository with a modified file
	clean_repos
	mk_repos "repos- a" a
	mk_repos repos-a a
	echo "AAA" >> "repos- a/a"
	echo "AAA" >> repos-a/a

	# One repository with a space character
	run_scanrepos space "repos- a"  || return 1
	check_same space.output space.output.ref || return 1

	# Two repositories with one with a space character
	run_scanrepos space_2_repos "repos- a" repos-a  || return 1
	check_same space_2_repos.output space_2_repos.output.ref || return 1
}

###################
# TEST SUBMODULES #
###################

function test_submodules {

	# Create two repositories
	clean_repos
	mk_repos repos-a a
	mk_repos repos-b b
	modify_repos_file repos-a a

	# Add one repository as submodule of the other
	cd repos-b
	run_git submodule add ../repos-a
	run_git commit -m "Add submodule."
	echo "AAA" >> repos-a/a
	cd ..

	run_scanrepos submodules repos-b || return 1
	check_same submodules.output submodules.output.ref || return 1

	run_scanrepos submodules_with_state_in_super -s repos-b || return 1
	check_same submodules_with_state_in_super.output submodules_with_state_in_super.output.ref || return 1

	run_git clone --recursive repos-b repos-clone-b
	run_scanrepos submodules_noinit -d repos-clone-b || return 1
	check_same submodules_noinit.output submodules_noinit.output.ref || return 1
}

########
# MAIN #
########

check test_submodules
check test_unknown_option -z
check test_modified_file
check test_deleted_file
check test_untracked_file
check test_branch_ahead
check test_branch_behind
check test_repospath
check test_fetch -f
check test_fetch --fetch
check test_pull -b
check test_pull --pull
check test_push -a
check test_push --push
check test_push_conflict -a
check test_push_conflict --push
check test_multiple_repospaths
check test_space

#!/bin/bash

##############
# PRINT HELP #
##############

function print_help {
	echo scan-repos [-h] [-g]
	echo -c  Enable checking of new commits for submodules. By default, it is disabled.
	echo -g  Debug mode.
	echo -h  Print this help message.
}

#############
# READ ARGS #
#############

function read_args {

	# Set default values
	debug=0

	while getopts "cfgh" flag ; do
		case $flag in
			h) print_help ; exit 0 ;;
			f) fetch=1 ;;
			g) debug=$((debug + 1)) ;;
			c) newcommits=1 ;;
		esac
	done
	shift $((OPTIND - 1))
}

###################
# PRINT DEBUG MSG #
###################

function print_debug_msg {

	lvl=$1
	msg=$2

	if [ $debug -ge $lvl ] ; then
		echo [DEBUG] $msg >&2
	fi
}

#########
# FETCH #
#########

function fetch {

	repospath=$1
	prevdir=$(pwd)

	cd $repospath
	print_debug_msg 1 "Fetching $repospath ..."
	pwd
	git fetch --all
	cd $prevdir
}

########
# MAIN #
########

read_args "$@"

REPOSPATH=$HOME/dev

curdir=$(pwd)

# Loop on all repository paths
for p in $REPOSPATH ; do

	# List all repositories in current path
	gitrepos=$(ls -d $p/*/.git | sed 's/\/\.git//g')

	# Loop on all repositories
	for repos in $gitrepos ; do

		# Get repository name
		reposname=$(basename $repos)

		# Change repository's directory
		cd $repos
		print_debug_msg 1 "Looking at status of $repos ..."

		# Fetch
		if [ -n "$fetch" ] ; then fetch $repos ; fi

		# Read repository's status
		git status | while read line ; do

			# Debug output
			print_debug_msg 2 "STATUS: $line"

			# Untracked files
			if [ -n "$(echo $line | grep '^Untracked files:')" ] ; then
				echo $reposname': '$'\e[33m''untracked files'$'\e[0m''.'

			# Modified files
			elif [ -n "$(echo $line | grep '^Modified files:')" ] ; then
				echo $reposname': '$'\e[31m''modified files'$'\e[0m''.'

			# Branch is behind
			elif [ -n "$(echo $line | grep 'branch is behind')" ] ; then
				echo $reposname': '$'\e[32m''behind'$'\e[0m''.'

			# Branch is ahead
			elif [ -n "$(echo $line | grep 'branch is ahead')" ] ; then
				echo $reposname': '$'\e[34m''ahead'$'\e[0m''.'

			# Submodule modified
			elif [ -n "$(echo $line | grep '^modified: ')" ] ; then
				submodule=$(echo $line | sed 's/^modified: \(.*\) (.*$/\1/')
				reason=$(echo $line | sed 's/^modified: .* (\(.*\))$/\1/')
				nbreasons=0
				msg="$reposname/$submodule: "

				# Fetch
				if [ -n "$fetch" ] ; then fetch $repos/$submodule ; fi

				# New commits
				if [ "$newcommits" = "1" -a -n "$(echo $reason | grep 'new commits')" ] ; then
					msg="${msg}new commits"
					nbreasons=$((nbreasons+1))
				fi

				# Modified content
				if [ -n "$(echo $reason | grep 'modified content')" ] ; then
					if [ $nbreasons -gt 0 ] ; then
						msg="$msg, "
					fi
					msg=$msg$'\e[31m''modified content'$'\e[0m'
					nbreasons=$((nbreasons+1))
				fi

				# Untracked content
				if [ -n "$(echo $reason | grep 'untracked content')" ] ; then
					if [ $nbreasons -gt 0 ] ; then
						msg="$msg, "
					fi
					msg=$msg$'\e[33m''untracked content'$'\e[0m'
					nbreasons=$((nbreasons+1))
				fi

				# Also each submodule which is only new-commits, must be checked if it is "ahead".
				if [ "$reason" = "new commits" ] ; then
					cd $submodule
					ahead=$(git status | grep 'branch is ahead')
					cd ..
					if [ -n "$ahead" ] ; then
						msg=$msg$'\e[34m''ahead'$'\e[0m'
						nbreasons=$((nbreasons+1))
					fi
				fi

				# Print message if there is one
				if [ $nbreasons -gt 0 ] ; then
					echo ${msg}.
				fi
			fi
		done # while loop on `git status` output.

		# Go back to initial directory
		cd $curdir
	done
done

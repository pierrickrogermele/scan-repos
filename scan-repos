#!/bin/bash

#############
# CONSTANTS #
#############

# State constants
((BRANCH_AHEAD          = 1 << 0))
((BRANCH_BEHIND         = 1 << 1))
((MODIFIED_FILES        = 1 << 2))
((BRANCH_PULLED         = 1 << 3))
((BRANCH_PUSHED         = 1 << 4))
((UNTRACKED_FILES       = 1 << 5))
((MODIFIED_SUBMODULES   = 1 << 6))
((BRANCH_DIVERGED       = 1 << 7))
((DELETED_FILES         = 1 << 8))
((DETACHED_HEAD         = 1 << 9))
((NOT_INITIALIZED       = 1 << 10)) # Submodule not initialized.
((INITIALIZED           = 1 << 11)) # Submodule has been initialized.
((BRANCH_UPTODATE       = 1 << 12))
((GIT_FAILURE           = 1 << 13))

####################
# GLOBAL VARIABLES #
####################

DEBUG=0
FETCH=
PULL=
PUSH=
SUBMODULES=
PROGRESS=
DETACHED=
INIT=
TRACKING=
BRANCHNAME=

declare -a REPOS

##############
# PRINT HELP #
##############

function print_help {
	echo "Usage: scan-repos [options] [repositories]"
	echo
	echo "Repositories are either real repositories or folders containing repositories."
	echo "If no repositories are specified, then the value of the environment variable REPOSPATH is used if it is set. Otherwise the current directory is used."
	echo
	echo "Options:"
	echo "   -a, --push         Push repositories whose current branch is ahead."
	echo "   -b, --pull         Pull repositories whose current branch is behind, and that have no modified files."
	echo "   -d, --detached     Display repositories whose HEAD is detached."
	echo "   -f, --fetch        Fetch repositories."
	echo "   -g, --debug        Debug mode."
	echo "   -h, --help         Print this help message."
	echo "   -i, --init         Initialize (and update) uninitialized submodules."
	echo "   -n, --branchname   Display current branch name."
	echo "   -p, --progress     Display progress bar."
	echo "   -s, --submodules   Check also the states of submodules."
	echo "   -t, --tracking     Detect branches that do not track a remote branch."
}

#########
# ERROR #
#########

function error {

	local msg=$1

	echo "ERROR: $msg" >&2

	exit 1
}

#############
# READ ARGS #
#############

function read_args {

	# Read options
	while true ; do
		case $1 in
			-a|--push)          PUSH=1 ;;
			-b|--pull)          PULL=1 ;;
			-d|--detached)      DETACHED=1 ;;
			-f|--fetch)         FETCH=1 ;;
			-g|--debug)         DEBUG=$((DEBUG + 1)) ;;
			-h|--help)          print_help ; exit 0 ;;
			-i|--init)          INIT=1 ;;
			-n|--branchname)    BRANCHNAME=1 ;;
			-p|--progress)      PROGRESS=1 ;;
			-s|--submodules)    SUBMODULES=1 ;;
			-t|--tracking)      TRACKING=1 ;;
			-) error "Illegal option $1." ;;
			--) error "Illegal option $1." ;;
			--*) error "Illegal option $1." ;;
			-?) error "Unknown option $1." ;;
			-[^-]*) split_opt=$(echo $1 | sed 's/^-//' | sed 's/\([a-z]\)/ -\1/g') ; set -- $1$split_opt "${@:2}" ;;
			*) break
		esac
		shift
	done
	shift $((OPTIND - 1))

	# Read remaining arguments as a list of repositories
	if [ -n "$*" ] ; then
		REPOS=("$@") # Replace any value of REPOSPATH with current specified list of repositories

	# Use value of REPOSPATH environment variable
	elif [ -n "$REPOSPATH" ] ; then
		oldifs=$IFS
		IFS=:
		for path in $REPOSPATH ; do
			REPOS+=("$path")
		done
		IFS=$oldifs

	# Use current directory
	else
		REPOS=(".")
	fi

	# Debug
	[ -n "$FETCH" ] && print_debug_msg 1 "Fetch enabled."
	[ -n "$PULL" ] && print_debug_msg 1 "Pull enabled."
	[ -n "$PUSH" ] && print_debug_msg 1 "Push enabled."
	[ -n "$DETACHED" ] && print_debug_msg 1 "Detached detection enabled."
	[ -n "$PROGRESS" ] && print_debug_msg 1 "Progress bar enabled."
	[ -n "$SUBMODULES" ] && print_debug_msg 1 "Submodules scanning enabled."
}

###################
# PRINT DEBUG MSG #
###################

function print_debug_msg {

	local dbglvl=$1
	local dbgmsg=$2

	if [ $DEBUG -ge $dbglvl ] ; then
		echo [DEBUG] $dbgmsg >&2
	fi
}

#####################
# PRINT WARNING MSG #
#####################

function print_warning_msg {

	local warnmsg=$1

	erase_progress_bar
	echo $'\e[31m''[WARNING]'" $warnmsg"$'\e[0m' >&2
}

#############
# PRINT MSG #
#############

function print_msg {

	local message=$1
	
	erase_progress_bar
	echo $message
}

######################
# ERASE PROGRESS BAR #
######################

function erase_progress_bar {
	if [ -n "$PROGRESS" ] ; then
		echo -n $'\r'"                                                            "$'\r'
	fi
}

######################
# PRINT PROGRESS BAR #
######################

function print_progress_bar {

	local title=$1
	local done=$2
	local total=$3
	local keepbar=$4
	local barsize=32
	local filledsize=$((done*barsize/total))
	local percent=$((done*100/total))

	if [ -n "$PROGRESS" ] ; then
		# Build bar
		local bar=
		local i=
		for((i=0;i<barsize;++i)) ; do
			if [ $i -lt $filledsize ] ; then
				bar="$bar#"
			else
				bar="$bar "
			fi
		done

		echo -n $'\r'
		if [ -n "$title" ] ; then
			echo -n "$title "
		fi
		echo -n "[$bar] ($percent%)"
		if [ $done -ge $total ] ; then
			if [ -n "$keepbar" ] ; then
				echo
			else
				erase_progress_bar
			fi
		else
			echo -n $'\r'
		fi
	fi
}

#######################
# RESOLVE REPOS PATHS #
#######################

function resolve_repos_paths {

	local -a tmprepos

	# Loop on all defined paths
	for path in "${REPOS[@]}" ; do

		# Get repositories
		if [ -e "$path/.git" ] ; then
			tmprepos+=("$path")
		else
			local list_repos_file=$(mktemp -t listrepos.XXXXXX)
			ls -1d "$path"/*/.git 2>/dev/null | sed 's/\/\.git$//g' > $list_repos_file
			while read rep ; do
				tmprepos+=("$rep")
			done < $list_repos_file
			rm $list_repos_file
		fi
	done

	REPOS=("${tmprepos[@]}")
}

###################
# GET STATUS FILE #
###################

function get_status_file {

	local repospath="$1"
	local repos_status_file=$(mktemp -t "scanrepos.status.XXXXXX")
	local prevdir=$(pwd)

	# Enter repository's directory
	cd "$repospath"

	# Get status
	print_debug_msg 1 "Getting repository \"$repospath\" status..."
	if [ ! -e .git ] ; then
		echo NOT INITIALIZED >$repos_status_file
		print_debug_msg 1 "Repository not initialized."
	elif ! git status >$repos_status_file ; then
		echo GIT FAILURE >$repos_status_file
		print_warning_msg "Failure on getting status of repository $repospath."
	fi

	# Go back to previous directory
	cd $prevdir

	# Return status filename
	print_debug_msg 1 "Repository \"$repospath\" status file is \"$repos_status_file\"."
	echo $repos_status_file
}

###############
# SCAN STATUS #
###############

function scan_status {

	local repos_status_file="$1"
	local status=0

	print_debug_msg 1 "Scanning repository status..."

	grep -q '^NOT INITIALIZED$'             "$repos_status_file" && ((status = status | NOT_INITIALIZED))
	grep -q '^GIT FAILURE$'                 "$repos_status_file" && ((status = status | GIT_FAILURE))
	grep -q '^Your branch is up-to-date'    "$repos_status_file" && ((status = status | BRANCH_UPTODATE))
	grep -q '^HEAD detached'                "$repos_status_file" && ((status = status | DETACHED_HEAD))
	grep -q '^Untracked files:'             "$repos_status_file" && ((status = status | UNTRACKED_FILES))
	grep -q 'modified: .* (.*)*$'           "$repos_status_file" && ((status = status | MODIFIED_SUBMODULES))
	grep -q 'deleted:[^(]*$'                "$repos_status_file" && ((status = status | DELETED_FILES))
	egrep -q 'modified:[^(]*$'              "$repos_status_file" && ((status = status | MODIFIED_FILES))
	grep -q 'branch is behind'              "$repos_status_file" && ((status = status | BRANCH_BEHIND))
	grep -q 'branch is ahead'               "$repos_status_file" && ((status = status | BRANCH_AHEAD))
	grep -q 'branch and .* have diverged'   "$repos_status_file" && ((status = status | BRANCH_DIVERGED))

	# Return status
	print_debug_msg 1 "Status = $status."
	echo $status
}

###################
# GET BRANCH NAME #
###################

function get_branch_name {

	local repos_status_file="$1"
	local branchname=""

	print_debug_msg 1 "Getting repository current branch name..."

	# Search for branchname inside status file
	branchname=$(sed -ne '1s/^On branch \(.*\)$/\1/p' "$repos_status_file")

	# Return branch name
	print_debug_msg 1 "Branch name is \"$branchname\"."
	echo "$branchname"
}

#########
# FETCH #
#########

function fetch_repos {

	local repospath=$1
	local prevdir=$(pwd)
	local quiet=--quiet
	if [ $DEBUG -ge 1 ] ; then quiet= ; fi

	cd $repospath
	print_debug_msg 1 "Fetching $repospath ..."

	if ! git fetch --all $quiet 2>/dev/null ; then
		print_warning_msg "Failure on fetching repository $repospath."
	fi

	cd $prevdir
}

##############
# PULL REPOS #
##############

function pull_repos {

	local repospath="$1"
	local status=$2
	local prevdir=$(pwd)

	cd "$repospath"
	print_debug_msg 1 "Pulling $repospath ..."

	if [ $((status & (BRANCH_BEHIND | BRANCH_DIVERGED) )) -ne 0 -a $((status & (MODIFIED_FILES | DELETED_FILES))) -eq 0 ] ; then
		if ! git pull >/dev/null ; then
			print_warning_msg "Failure on pulling repository $repospath."
		else
			if [ $((status & BRANCH_DIVERGED)) -ne 0 ] ; then
				((status = status | BRANCH_AHEAD))
			fi
			((status = status ^ (status & (BRANCH_BEHIND | BRANCH_DIVERGED) ) ))
			((status = status | BRANCH_PULLED))
		fi
	fi

	cd $prevdir

	echo $status
}

########################
# INITIALIZE SUBMODULE #
########################

function init_submodule {

	local repospath="$1"
	local status=$2
	local prevdir=$(pwd)

	cd "$repospath"
	print_debug_msg 1 "Initializing $repospath ..."

	if [ $((status & NOT_INITIALIZED)) -ne 0 ] ; then
		if ! git submodule update --init --recursive . >/dev/null 2>&1 ; then
			print_warning_msg "Failure on updating submodules of repository $repospath."
		else
			((status = status ^ (status & NOT_INITIALIZED) ))
			((status = status | INITIALIZED))
		fi
	fi

	cd $prevdir

	echo $status
}

##############
# PUSH REPOS #
##############

function push_repos {

	local repospath="$1"
	local status=$2
	local prevdir=$(pwd)

	cd "$repospath"
	print_debug_msg 1 "Pushing $repospath ..."

	if [ $((status & BRANCH_AHEAD)) -ne 0 ] ; then
		if ! git push >/dev/null 2>&1 ; then
			print_warning_msg "Failure on pushing repository $repospath."
		else
			((status = status ^ (status & BRANCH_AHEAD) ))
			((status = status | BRANCH_PUSHED))
		fi
	fi

	cd $prevdir

	echo $status
}

################
# PRINT STATUS #
################

function print_status {

	local repospath="$1"
	local branch=$2
	local status=$3

	local msg=

	print_debug_msg 1 "Printing status $status of $repospath ..."

	# State
	[ $((status & BRANCH_DIVERGED)) -ne 0 ]                 && msg="$msg, "$'\e[36m''branch has diverged'$'\e[0m'
	[ $((status & BRANCH_BEHIND)) -ne 0 ]                   && msg="$msg, "$'\e[32m''branch is behind'$'\e[0m'
	[ $((status & BRANCH_AHEAD)) -ne 0 ]                    && msg="$msg, "$'\e[34m''branch is ahead'$'\e[0m'
	[ $((status & UNTRACKED_FILES)) -ne 0 ]                 && msg="$msg, "$'\e[33m''untracked files'$'\e[0m'
	[ $((status & MODIFIED_FILES)) -ne 0 ]                  && msg="$msg, "$'\e[31m''modified files'$'\e[0m'
	[ $((status & DELETED_FILES)) -ne 0 ]                   && msg="$msg, "$'\e[31m''deleted files'$'\e[0m'
	[ $((status & MODIFIED_SUBMODULES)) -ne 0 ]             && msg="$msg, "$'\e[35m''modified submodules'$'\e[0m'
	[ $((status & GIT_FAILURE)) -ne 0 ]                     && msg="$msg, "$'\e[35m''git failure'$'\e[0m'
	[ $((status & NOT_INITIALIZED)) -ne 0 ]                 && msg="$msg, "$'\e[35m''not initialized'$'\e[0m'
	[ $((status & INITIALIZED)) -ne 0 ]                     && msg="$msg, "$'\e[35m''initialized'$'\e[0m'
	[ -n "$DETACHED" -a $((status & DETACHED_HEAD)) -ne 0 ] && msg="$msg, "$'\e[31m''detached head'$'\e[0m'
	[ -n "$TRACKING" -a $((status & (NOT_INITIALIZED | DETACHED_HEAD | BRANCH_BEHIND | BRANCH_AHEAD | BRANCH_UPTODATE))) -eq 0 ] && msg="$msg, "$'\e[31m''no tracking'$'\e[0m'

	# Actions
	[ $((status & BRANCH_PULLED)) -ne 0 ]                   && msg="$msg, "$'\e[1;32m''branch has been pulled'$'\e[0m'
	[ $((status & BRANCH_PUSHED)) -ne 0 ]                   && msg="$msg, "$'\e[1;34m''branch has been pushed'$'\e[0m'

	# Display message
	if [ -n "$msg" ] ; then
		msg=${msg#, } # Remove first comma
		header=$repospath
		[ -n "$BRANCHNAME" -a -n "$branch" ] && header="$header($branch)"
		print_msg "$header: ${msg}."
	fi
}

############
# SCAN ALL #
############

function scan_all {

	local -i i=1
	for rep in "${REPOS[@]}" ; do
		print_progress_bar "Scanning" $i ${#REPOS[@]}

		# Fetch
		[ -n "$FETCH" ] && fetch_repos "$rep"

		# Scan
		status_file=$(get_status_file "$rep")
		status=$(scan_status "$status_file")
		branch=$(get_branch_name "$status_file")

		# Initialize submodule
		if [ -n "$INIT" -a -n "$SUBMODULES" ] ; then
			status=$(init_submodule "$rep" $status)
		fi

		# Pull
		if [ -n "$PULL" ] ; then
			status=$(pull_repos "$rep" $status)
		fi

		# Push
		if [ -n "$PUSH" ] ; then
			status=$(push_repos "$rep" $status)
		fi

		print_status "$rep" "$branch" $status

		i+=1
	done
}

###################
# LIST SUBMODULES #
###################

function list_submodules {

	local origdir=$(pwd)
	local -a tmprepos

	# Loop on all defined paths
	for rep in "${REPOS[@]}" ; do

		tmprepos+=("$rep")
		cd "$rep"
		local list_submodules_file=$(mktemp -t listrepos.XXXXXX)
		git submodule status --recursive | sed 's/^.[0-9a-f]* //' | sed 's/ \(.*\)$//' > $list_submodules_file
		cd "$origdir"
		while read subrep ; do
			tmprepos+=("$rep/$subrep")
		done < $list_submodules_file
		rm $list_submodules_file
	done

	REPOS=("${tmprepos[@]}")
}

########
# MAIN #
########

read_args "$@"

# List all repositories
resolve_repos_paths

# List submodules
[ -n "$SUBMODULES" ] &&	list_submodules

# Scan
scan_all

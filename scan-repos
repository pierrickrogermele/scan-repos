#!/bin/bash

##############
# PRINT HELP #
##############

function print_help {
	echo scan-repos [-h] [-g]
	echo -c  Enable checking of new commits for submodules. By default, it is disabled.
	echo -g  Debug mode.
	echo -h  Print this help message.
}

#############
# READ ARGS #
#############

function read_args {
	while getopts "hg" flag ; do
		case $flag in
			h) print_help ; exit 0 ;;
			g) debug=1 ;;
			c) newcommits=1 ;;
		esac
	done
	shift $((OPTIND - 1))
}

########
# MAIN #
########

read_args "$@"

REPOSPATH=$HOME/dev

curdir=$(pwd)

# Loop on all repository paths
for p in $REPOSPATH ; do

	# List all repositories in current path
	gitrepos=$(ls -d $p/*/.git | sed 's/\/\.git//g')

	# Loop on all repositories
	for r in $gitrepos ; do

		# Get repository name
		reposname=$(basename $r)

		# Change repository's directory
		cd $r

		# Read repository's status
		git status | while read line ; do

			# Debug output
			if [ "$debug" = "1" ] ; then
				echo DEBUG $line
			fi

			# Untracked files
			if [ -n "$(echo $line | grep '^Untracked files:')" ] ; then
				echo $reposname': '$'\e[33m''untracked files'$'\e[0m''.'

			# Modified files
			elif [ -n "$(echo $line | grep '^Modified files:')" ] ; then
				echo $reposname': '$'\e[31m''modified files'$'\e[0m''.'

			# Branch is behind
			elif [ -n "$(echo $line | grep 'branch is behind')" ] ; then
				echo $reposname': '$'\e[32m''behind'$'\e[0m''.'

			# Branch is ahead
			elif [ -n "$(echo $line | grep 'branch is ahead')" ] ; then
				echo $reposname': '$'\e[34m''ahead'$'\e[0m''.'

			# Submodule modified
			elif [ -n "$(echo $line | grep '^modified: ')" ] ; then
				submodule=$(echo $line | sed 's/^modified: \(.*\) (.*$/\1/')
				reason=$(echo $line | sed 's/^modified: .* (\(.*\))$/\1/')
				nbreasons=0
				msg="$reposname/$submodule: "

				# New commits
				if [ "$newcommits" = "1" -a -n "$(echo $reason | grep 'new commits')" ] ; then
					msg="${msg}new commits"
					nbreasons=$((nbreasons+1))
				fi

				# Modified content
				if [ -n "$(echo $reason | grep 'modified content')" ] ; then
					if [ $nbreasons -gt 0 ] ; then
						msg="$msg, "
					fi
					msg=$msg$'\e[31m''modified content'$'\e[0m'
					nbreasons=$((nbreasons+1))
				fi

				# Untracked content
				if [ -n "$(echo $reason | grep 'untracked content')" ] ; then
					if [ $nbreasons -gt 0 ] ; then
						msg="$msg, "
					fi
					msg=$msg$'\e[33m''untracked content'$'\e[0m'
					nbreasons=$((nbreasons+1))
				fi

				# Also each submodule which is only new-commits, must be checked if it is "ahead".
				if [ "$reasons" = "new commits" ] ; then
					cd $submodule
					ahead=$(git status | grep 'branch is ahead')
					cd ..
					if [ -n "$ahead" ] ; then
						msg=$msg$'\e[34m''ahead'$'\e[0m'
						nbreasons=$((nbreasons+1))
					fi
				fi

				# Print message if there is one
				if [ $nbreasons -gt 0 ] ; then
					echo ${msg}.
				fi
			fi
		done # while loop on `git status` output.

		# Go back to initial directory
		cd $curdir
	done
done

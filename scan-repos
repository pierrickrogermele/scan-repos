#!/bin/bash

#############
# CONSTANTS #
#############

# State constants
((BRANCH_AHEAD          = 1 << 0))
((BRANCH_BEHIND         = 1 << 1))
((MODIFIED_FILES        = 1 << 2))
((BRANCH_PULLED         = 1 << 3))
((BRANCH_PUSHED         = 1 << 4))
((UNTRACKED_FILES       = 1 << 5))
((MODIFIED_SUBMODULES   = 1 << 6))
((BRANCH_DIVERGED       = 1 << 7))
((DELETED_FILES         = 1 << 8))

####################
# GLOBAL VARIABLES #
####################

DEBUG=0
FETCH=
PULL=
PUSH=
SUBMODULES=
PROGRESS=

declare -a REPOS

##############
# PRINT HELP #
##############

function print_help {
	echo "Usage: scan-repos [options] [repositories]"
	echo
	echo "Repositories are either real repositories or folders containing repositories."
	echo "If no repositories are specified, then the value of the environment variable REPOSPATH is used if it is set. Otherwise the current directory is used."
	echo
	echo "Options:"
	echo "   -a, --push         Push repositories whose current branch is ahead."
	echo "   -b, --pull         Pull repositories whose current branch is behind, and that have no modified files."
	echo "   -f, --fetch        Fetch repositories."
	echo "   -g, --debug        Debug mode."
	echo "   -h, --help         Print this help message."
	echo "   -p, --progress     Display progress bar."
	echo "   -s, --submodules   Check also the states of submodules."
}

#########
# ERROR #
#########

function error {

	local msg=$1

	echo "ERROR: $msg" >&2

	exit 1
}

#############
# READ ARGS #
#############

function read_args {

	# Read options
	while true ; do
		case $1 in
			-a|--push)          PUSH=1 ;;
			-b|--pull)          PULL=1 ;;
			-f|--fetch)         FETCH=1 ;;
			-g|--debug)         DEBUG=$((DEBUG + 1)) ;;
			-h|--help)          print_help ; exit 0 ;;
			-p|--progress)      PROGRESS=1 ;;
			-s|--submodules)    SUBMODULES=1 ;;
			-*) error "Unknown option $1." ;;
			*) break
		esac
		shift
	done
	shift $((OPTIND - 1))

	# Read left arguments as list of repositories
	if [ -n "$*" ] ; then
		REPOSPATH="$*" # Replace any value of REPOSPATH with current specified list of repositories
	elif [ -z "$REPOSPATH" ] ; then
		REPOSPATH=. # Use current directory
	fi
}

###################
# PRINT DEBUG MSG #
###################

function print_debug_msg {

	local dbglvl=$1
	local dbgmsg=$2

	if [ $DEBUG -ge $dbglvl ] ; then
		echo [DEBUG] $dbgmsg >&2
	fi
}

#####################
# PRINT WARNING MSG #
#####################

function print_warning_msg {

	local warnmsg=$1

	erase_progress_bar
	echo $'\e[31m''[WARNING]'" $warnmsg"$'\e[0m' >&2
}

#############
# PRINT MSG #
#############

function print_msg {

	local message=$1
	
	erase_progress_bar
	echo $message
}

######################
# ERASE PROGRESS BAR #
######################

function erase_progress_bar {
	if [ -n "$PROGRESS" ] ; then
		echo -n $'\r'"                                                            "$'\r'
	fi
}

######################
# PRINT PROGRESS BAR #
######################

function print_progress_bar {

	local title=$1
	local done=$2
	local total=$3
	local keepbar=$4
	local barsize=32
	local filledsize=$((done*barsize/total))
	local percent=$((done*100/total))

	if [ -n "$PROGRESS" ] ; then
		# Build bar
		bar=
		for((i=0;i<barsize;++i)) ; do
			if [ $i -lt $filledsize ] ; then
				bar="$bar#"
			else
				bar="$bar "
			fi
		done

		echo -n $'\r'
		if [ -n "$title" ] ; then
			echo -n "$title "
		fi
		echo -n "[$bar] ($percent%)"
		if [ $done -ge $total ] ; then
			if [ -n "$keepbar" ] ; then
				echo
			else
				erase_progress_bar
			fi
		else
			echo -n $'\r'
		fi
	fi
}

#########
# FETCH #
#########

function fetch {

	local repospath=$1
	local prevdir=$(pwd)
	local quiet=--quiet
	if [ $DEBUG -ge 1 ] ; then quiet= ; fi

	cd $repospath
	print_debug_msg 1 "Fetching $repospath ..."

	if ! git fetch --all $quiet 2>/dev/null ; then
		print_warning_msg "Can't fetch repository $repospath."
	fi

	cd $prevdir
}

#############
# FETCH ALL #
#############

function fetch_all {

	local -i i=1
	for rep in "${REPOS[@]}" ; do
		print_progress_bar "Fetching" $i ${#REPOS[@]}
		fetch $rep
		i+=1
	done
}

##############
# LIST REPOS #
##############

function list_repos {

	local prevdir=$(pwd)

	# Use colon as separator
	oldifs=$IFS
	IFS=:

	# Loop on all defined paths
	for path in $REPOSPATH ; do

		# Get repositories
		if [ -e "$path/.git" ] ; then
			repos="$path"
		else
			repos=$(ls -1d "$path"/*/.git | sed 's/\/\.git$//g' | tr "\n" ":")
		fi

		# Loop on all repos
		for rep in $repos ; do
			REPOS+=("$rep")
			cd $rep
			git submodule foreach true | sed "s/^Entering '\(.*\)'$/\1/" | sed s@^@$rep/@
			cd $prevdir
		done
	done

	# Reset separator to old value
	IFS=$oldifs
}

########
# SCAN #
########

function scan {

	local repospath="$1"
	local prevdir=$(pwd)
	local repos_status_file=$(mktemp -t reposstatus.XXXXXX)

	cd "$repospath"
	print_debug_msg 1 "Scanning $repospath ..."

	# Read repository's status
	if ! git status >$repos_status_file ; then
		print_warning_msg "Can't get status of repository $repospath."
	else

		# Status var
		status=0

		# Read status line by line
		while read line ; do

			# Debug output
			print_debug_msg 2 "STATUS: $line"

			# Untracked files
			if [ -n "$(echo $line | grep '^Untracked files:')" ] ; then
				((status = status | UNTRACKED_FILES))
			fi

			# Modified submodules
			if [ -n "$SUBMODULES" -a -n "$(echo $line | egrep 'modified: .* (.*)*$')" ] ; then
				((status = status | MODIFIED_SUBMODULES))
			fi

			# Deleted files
			if [ -n "$(echo $line | egrep 'deleted:[^(]*$')" ] ; then
				((status = status | DELETED_FILES))
			fi

			# Modified files
			if [ -n "$(echo $line | egrep 'modified:[^(]*$')" ] ; then
				((status = status | MODIFIED_FILES))
			fi

			# Branch is behind
			if [ -n "$(echo $line | grep 'branch is behind')" ] ; then
				((status = status | BRANCH_BEHIND))
			fi

			# Branch is ahead
			if [ -n "$(echo $line | grep 'branch is ahead')" ] ; then
				((status = status | BRANCH_AHEAD))
			fi

			# Branch has diverged
			if [ -n "$(echo $line | grep 'branch and .* have diverged')" ] ; then
				((status = status | BRANCH_DIVERGED))
			fi

		done <$repos_status_file

		# Pull
		if [ -n "$PULL" -a $((status & (BRANCH_BEHIND | BRANCH_DIVERGED) )) -ne 0 -a $((status & (MODIFIED_FILES | DELETED_FILES))) -eq 0 ] ; then
			if ! git pull >/dev/null ; then
				print_warning_msg "Can't run pull on repository $repospath."
			else
				if [ $((status & BRANCH_DIVERGED)) -ne 0 ] ; then
					((status = status | BRANCH_AHEAD))
				fi
				((status = status ^ (status & (BRANCH_BEHIND | BRANCH_DIVERGED) ) ))
				((status = status | BRANCH_PULLED))
			fi
		fi

		# Push
		if [ -n "$PUSH" -a $((status & BRANCH_AHEAD)) -ne 0 ] ; then
			if ! git push >/dev/null 2>&1 ; then
				print_warning_msg "Can't run push on repository $repospath."
			else
				((status = status ^ (status & BRANCH_AHEAD) ))
				((status = status | BRANCH_PUSHED))
			fi
		fi

		# Print message
		if [ "$status" -ne 0 ] ; then
			msg=
			if [ $((status & BRANCH_DIVERGED)) -ne 0 ] ; then
				if [ -n "$msg" ] ; then msg="$msg, " ; fi
				msg=$msg$'\e[36m''branch has diverged'$'\e[0m'
			fi
			if [ $((status & BRANCH_BEHIND)) -ne 0 ] ; then
				if [ -n "$msg" ] ; then msg="$msg, " ; fi
				msg=$msg$'\e[32m''branch is behind'$'\e[0m'
			fi
			if [ $((status & BRANCH_PULLED)) -ne 0 ] ; then
				if [ -n "$msg" ] ; then msg="$msg, " ; fi
				msg=$msg$'\e[1;32m''branch has been pulled'$'\e[0m'
			fi
			if [ $((status & BRANCH_AHEAD)) -ne 0 ] ; then
				if [ -n "$msg" ] ; then msg="$msg, " ; fi
				msg=$msg$'\e[34m''branch is ahead'$'\e[0m'
			fi
			if [ $((status & BRANCH_PUSHED)) -ne 0 ] ; then
				if [ -n "$msg" ] ; then msg="$msg, " ; fi
				msg=$msg$'\e[1;34m''branch has been pushed'$'\e[0m'
			fi
			if [ $((status & UNTRACKED_FILES)) -ne 0 ] ; then
				if [ -n "$msg" ] ; then msg="$msg, " ; fi
				msg=$msg$'\e[33m''untracked files'$'\e[0m'
			fi
			if [ $((status & MODIFIED_FILES)) -ne 0 ] ; then
				if [ -n "$msg" ] ; then msg="$msg, " ; fi
				msg=$msg$'\e[31m''modified files'$'\e[0m'
			fi
			if [ $((status & DELETED_FILES)) -ne 0 ] ; then
				if [ -n "$msg" ] ; then msg="$msg, " ; fi
				msg=$msg$'\e[1;31m''deleted files'$'\e[0m'
			fi
			if [ $((status & MODIFIED_SUBMODULES)) -ne 0 ] ; then
				if [ -n "$msg" ] ; then msg="$msg, " ; fi
				msg=$msg$'\e[35m''modified submodules'$'\e[0m'
			fi
			print_msg "$repospath: ${msg}."
		fi
	fi

	cd $prevdir
}

############
# SCAN ALL #
############

function scan_all {

	local -i i=1
	for rep in "${REPOS[@]}" ; do
		print_progress_bar "Scanning" $i ${#REPOS[@]}
		scan "$rep"
		i+=1
	done
}

########
# MAIN #
########

read_args "$@"

# List all repositories
list_repos

# Fetch
if [ -n "$FETCH" -o -n "$PULL" ] ; then fetch_all ; fi

# Scan
scan_all
